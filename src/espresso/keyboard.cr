require "glfw"
require "./bool_conversion"
require "./error_handling"
require "./event_handling"

module Espresso
  # Information about the keyboard that is associated with a window.
  # Each `Window` has its own keyboard instance with properties specific to that window.
  # To retrieve a keyboard instance, use `Window#keyboard`.
  #
  # GLFW divides keyboard input into two categories; key events and character events.
  # Key events relate to actual physical keyboard keys,
  # whereas character events relate to the Unicode code points generated by pressing some of them.
  #
  # Keys and characters do not map 1:1.
  # A single key press may produce several characters,
  # and a single character may require several keys to produce.
  # This may not be the case on your machine,
  # but your users are likely not all using the same keyboard layout,
  # input method or even operating system as you.
  struct Keyboard
    include BoolConversion
    include ErrorHandling
    include EventHandling

    # Creates the keyboard instance from a GLFW window pointer.
    protected def initialize(@pointer : LibGLFW::Window)
    end

    # Retrieves the last state reported for the specified key to the associated window.
    # The returned state is one of `KeyState::Pressed` or `KeyState::Released`.
    # The higher-level action `KeyState::Repeated` is only reported to the `#on_key` event.
    #
    # If the `#sticky?` input mode is enabled,
    # this method returns `KeyState::Pressed` the first time you call it for a key that was pressed,
    # even if that key has already been released.
    #
    # The key method deal with physical keys,
    # with key tokens (see: `Key`) named after their use on the standard US keyboard layout.
    # If you want to input text, use the Unicode character callback instead (see `#on_char`).
    #
    # The modifier key bit masks are not key tokens and cannot be used with this method.
    #
    # **Do not use this method** to implement text input.
    def key(key)
      value = expect_truthy { LibGLFW.get_key(@pointer, key) }
      KeyState.from_value(value.to_i)
    end

    # Determines whether the last state reported for the specified key is pressed.
    #
    # If the `#sticky?` input mode is enabled,
    # this method returns true the first time you call it for a key that was pressed,
    # even if that key has already been released.
    def key?(key)
      self.key(key).pressed?
    end

    # Indicates whether stick keys is enabled.
    # This is not the infamous [Windows sticky keys](https://en.wikipedia.org/wiki/Sticky_keys).
    # If sticky keys are enabled, a key press will ensure that `#key` returns `KeyState::Pressed`
    # the next time it is called even if the key had been released before the call.
    # This is useful when you are only interested in whether keys have been pressed
    # but not when or in which order.
    #
    # See also: `#sticky=`
    def sticky?
      value = expect_truthy { LibGLFW.get_input_mode(@pointer, LibGLFW::InputMode::StickyKeys) }
      int_to_bool(value)
    end

    # Enables or disables sticky keys.
    # This is not the infamous [Windows sticky keys](https://en.wikipedia.org/wiki/Sticky_keys).
    # If sticky keys are enabled, a key press will ensure that `#key` returns `KeyState::Pressed`
    # the next time it is called even if the key had been released before the call.
    # This is useful when you are only interested in whether keys have been pressed
    # but not when or in which order.
    #
    # Whenever you poll state (via `#key`),
    # you risk missing the state change you are looking for.
    # If a pressed key is released again before you poll its state,
    # you will have missed the key press.
    # The recommended solution for this is to use `#on_key`,
    # but there is also the sticky key input mode.
    #
    # Possible errors that could be raised are: `NotInitializedError` and `PlatformError`.
    #
    # See also: `#sticky?`
    def sticky=(flag)
      value = bool_to_int(flag)
      checked { LibGLFW.set_input_mode(@pointer, LibGLFW::InputMode::StickyKeys, value) }
    end

    # Indicates whether lock key modifier flags are enabled.
    # If enabled, callbacks that receive modifier bits
    # will also have the `ModifierKey::CapsLock` flag set
    # when the event was generated with Caps Lock on,
    # and the `ModifierKey::NumLock` flag when Num Lock was on.
    def lock_key_modifiers?
      value = expect_truthy { LibGLFW.get_input_mode(@pointer, LibGLFW::InputMode::LockKeyMods) }
      int_to_bool(value)
    end

    # Enables or disables lock key modifier flags.
    # If enabled, callbacks that receive modifier bits
    # will also have the `ModifierKey::CapsLock` flag set
    # when the event was generated with Caps Lock on,
    # and the `ModifierKey::NumLock` flag when Num Lock was on.
    def lock_key_modifiers=(flag)
      value = bool_to_int(flag)
      checked { LibGLFW.set_input_mode(@pointer, LibGLFW::InputMode::LockKeyMods, value) }
    end

    # Retrieves the underlying window pointer.
    def to_unsafe
      @pointer
    end
  end
end
